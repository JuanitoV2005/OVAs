<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sistemas Numéricos Quiz</title>
    <link rel="stylesheet" href="style.css">
</head>
<body>

    <div class="content" id="intro" style="min-height: 450px;">
        <h1>Tipos de Datos Primitivos</h1>
        
        <p>Ya sabes que todo en el mundo digital se reduce a ceros y unos, a esos bits que se combinan para formar nibbles y bytes. 
        Pero, ¿cómo usa Java estos bits para almacenar cosas como números enteros, números con decimales, o incluso letras? 
        Aquí es donde entran los tipos de datos primitivos.</p>

        <p>Los tipos de datos primitivos son los bloques de construcción más básicos para almacenar información en Java. 
        Son como los diferentes tipos de cajas que puedes usar para guardar tus objetos, y cada caja tiene un tamaño y una capacidad específica.</p>
        
        <p><b>¿Por qué son "primitivos"?</b><br>
        Son "primitivos" porque son los tipos de datos fundamentales que Java entiende directamente, sin necesidad de objetos complejos (más sobre esto en capítulos siguientes). 
        Son la forma más eficiente de almacenar valores simples en la memoria de un computador.</p>
        
        <div style="width:100%; background-color: #edf7ff; margin:0; padding:0">
        <!-- <img src="assets/img/cajas-tipos-datos.jpg" alt="Cajas representando los tipos de datos primitivos en Java, dividido en categorías"> -->
        </div>

        <p>Java tiene 8 tipos de datos primitivos, categorizados de la siguiente manera:<br>
        <ul>
            <li><strong>Enteros:</strong> byte, short, int, long.</li>
            <li><strong>Punto flotante:</strong> float, double.</li>
            <li><strong>Otros:</strong> char, boolean.</li>
        </ul>
        </p>
    
    </div>

    <div class="content hidden" id="enteros-rangos">

        <h1>Tipos de Datos Enteros en Java</h1>

        <p>
        Para un uso práctico eficiente de los tipos de datos enteros en Java, 
        es indispensable tener presente el rango y el tamaño de cada uno. 
        Conocer las capacidades de byte, short, int y long te permitirá seleccionar el tipo más apropiado para tus variables, 
        optimizando así el consumo de memoria y evitando posibles desbordamientos de datos que podrían causar errores en tu programa.
        </p>

        <section class="card-grid">
        <!-- BYTE -->
        <div class="card-teoria">
            <div class="card-bar red"></div>
            <div class="card-body">
            <div class="card-header">
                <h2>byte</h2>
                <span class="badge">8 bits</span>
            </div>
            <p>El tipo más pequeño, ideal para ahorrar memoria en arrays grandes</p>
            <div class="card-info">
                <p><strong>Tamaño:</strong> 1 byte</p>
                <progress value="12.5" max="100"></progress>
                <small>8 bits de 64</small>
            </div>
            <div class="card-range">
                <strong>Rango de valores:</strong>
                <div class="range-box">
                <div>Mínimo: -128</div>
                <div>Máximo: 127</div>
                </div>
            </div>
            <div class="example">
                <strong>Ejemplo:</strong>
                <code>byte edad = 25;</code>
            </div>
            </div>
        </div>

        <!-- SHORT -->
        <div class="card-teoria">
            <div class="card-bar orange"></div>
            <div class="card-body">
            <div class="card-header">
                <h2>short</h2>
                <span class="badge">16 bits</span>
            </div>
            <p>Útil cuando necesitas más rango que byte pero menos que int</p>
            <div class="card-info">
                <p><strong>Tamaño:</strong> 2 bytes</p>
                <progress value="25" max="100"></progress>
                <small>16 bits de 64</small>
            </div>
            <div class="card-range">
                <strong>Rango de valores:</strong>
                <div class="range-box">
                <div>Mínimo: -32.768</div>
                <div>Máximo: 32.767</div>
                </div>
            </div>
            <div class="example">
                <strong>Ejemplo:</strong>
                <code>short año = 2024;</code>
            </div>
            </div>
        </div>

        <!-- INT -->
        <div class="card-teoria">
            <div class="card-bar blue"></div>
            <div class="card-body">
            <div class="card-header">
                <h2>int</h2>
                <span class="badge">32 bits</span>
            </div>
            <p>El tipo entero más común, usado por defecto para números enteros</p>
            <div class="card-info">
                <p><strong>Tamaño:</strong> 4 bytes</p>
                <progress value="50" max="100"></progress>
                <small>32 bits de 64</small>
            </div>
            <div class="card-range">
                <strong>Rango de valores:</strong>
                <div class="range-box">
                <div>Mínimo: -2.147.483.648</div>
                <div>Máximo: 2.147.483.647</div>
                </div>
            </div>
            <div class="example">
                <strong>Ejemplo:</strong>
                <code>int poblacion = 1000000;</code>
            </div>
            </div>
        </div>

        <!-- LONG -->
        <div class="card-teoria">
            <div class="card-bar green"></div>
            <div class="card-body">
            <div class="card-header">
                <h2>long</h2>
                <span class="badge">64 bits</span>
            </div>
            <p>Para números muy grandes, requiere sufijo 'L' (mayúscula para evitar ambiguedades).</p>
            <div class="card-info">
                <p><strong>Tamaño:</strong> 8 bytes</p>
                <progress value="100" max="100"></progress>
                <small>64 bits de 64</small>
            </div>
            <div class="card-range">
                <strong>Rango de valores:</strong>
                <div class="range-box">
                <div>Mínimo: -9.223.372.036.854.775.808</div>
                <div>Máximo: 9.223.372.036.854.775.807</div>
                </div>
            </div>
            <div class="example">
                <strong>Ejemplo:</strong>
                <code>long distancia = 9460730472580800L;</code>
            </div>
            </div>
        </div>
        </section>
        <br><br>
    </div>

    <div class="content hidden" id="complemento-a-dos">
        <h1>Tipos de Datos Enteros en Java</h1>

        <h2>1. Byte</h2>
    <p>Hasta ahora, hemos visto que con un byte, 8 bits, podemos representar números que van desde el 0 (todos los bits en cero: 00000000) 
    hasta el 255 (todos los bits en uno: 11111111), como muestra el rango de la imagen:</p>
    <img class="data-range" src="assets/img/rango-byte-positivo.png" alt="Recta con rango de 0 a 255 en binario con un byte.""/>

    <p>Sin embargo, cuando trabajamos con el tipo de dato byte en Java, la historia cambia un poco. 
    No solo queremos guardar números positivos, sino que también necesitamos la capacidad de representar números negativos. 
    Java y la mayoría de los sistemas modernos eligen una solución elegante y eficiente para lograrlo: el Complemento a Dos.</p>

    <h3>Complemento a 2</h3>
    <p>Con esta estrategia, la forma en que "leemos" y "escribimos" esos 8 bits se modifica. 
    La clave está en que prestamos el bit más significativo para un uso exclusivo: indicar si el número es negativo o no. 
    Si ese bit es un <code>0</code>, sabemos que el número es <b>positivo</b>; si es un <code>1</code>, es <b>negativo</b>.</p>

    <p>Los 7 bits restantes son los que usamos para la "cantidad" del número. 
    Con esto, podemos representar 128 números negativos, el cero y 127 números positivos. Visualmente, este nuevo rango rango se vería así:</p>
    <img class="data-range" src="assets/img/rango-byte-negativo.png" alt="Recta con rango de -128 a 127 en binario con un byte, usando complemento a 2."/>
    
    <h2>Reto 1</h2>

    </div>

    <div class="content hidden" id="punto-flotante-bits">
        <h1>Tipo de Datos Punto Flotante en Java</h1>
        <h2>Comprender los "Decimales" de la Computadora</h2>
        <p class="float-paragraph">
            Cuando trabajamos con números que tienen partes decimales en Java (como 3.14 o -0.005),
            Java nos ofrece <strong>float</strong> y <strong>double</strong>, que son tipos de punto flotante.
            Las computadoras almacenan estos números de manera que se optimiza tanto el rango de valores
            que pueden representar (desde números muy pequeños hasta muy grandes) como la precisión.
        </p>

        <p>
            Esta representación sigue un estándar internacional conocido como <strong>IEEE 754</strong>, 
            que divide el espacio de bits en tres secciones clave:
        </p>

        <ol id="bit-description">
        <li>
        <strong>Bit de Signo (1 bit):</strong> Así como los enteros, un 0 indica que el número es positivo,
        y un 1 indica que es negativo.
        </li>
        <li>
        <strong>Exponente (8 bits para float, 11 bits para double):</strong> Esta parte define el 'tamaño'
        general del número. Similar a la notación científica, nos dice dónde está el 'punto decimal flotante'.
        Para poder manejar los exponentes negativos como números positivos, siempre se suma un 'sesgo' (offset)
        al valor real.
        </li>
        <li>
        <strong>Mantisa o Fracción (23 bits para float, 52 bits para double):</strong> Representa los dígitos
        'significativos' del número, similar a los dígitos que ves en una calculadora. Cuantos más bits tenga la mantisa,
        mayor será la precisión del número. Se asume un '1' implícito al inicio de la mantisa para ahorrar un bit
        de almacenamiento.
        </li>
        </ol>
    </div>

    <div class="content hidden" id="enunciado2">

  <h2>2. Short e Int</h2>
  <p>Después de trabajar con un <b>byte</b>, es hora de conocer otros tipos de datos enteros con mayor capacidad: <code>short</code> e <code>int</code>.</p>

  <p>Ambos tipos también almacenan solo números enteros, pero ocupan más espacio en memoria y permiten representar valores mucho mayores.</p>

  <h3>¿Cuántos valores pueden almacenar?</h3>
  <ul>
    <li><code>short</code>: usa 16 bits (2 bytes) → puede representar <b>65,536 valores diferentes</b>.</li>
    <li><code>int</code>: usa 32 bits (4 bytes) → puede representar <b>más de 4 mil millones de valores</b>.</li>
  </ul>

  <p>Al igual que con <code>byte</code>, estos tipos también usan el <b>Complemento a Dos</b> para representar números negativos.</p>

  <h3>Rango con signo (signed)</h3>
  <ul>
    <li><code>short</code>: de -32,768 a 32,767</li>
    <li><code>int</code>: de -2,147,483,648 a 2,147,483,647</li>
  </ul>

  <img class="data-range" src="assets/img/rango-short-negativo.png" alt="Recta con rango de -32768 a 32767 en binario con short."/>
  <img class="data-range" src="assets/img/rango-int-negativo.png" alt="Recta con rango de int en binario con complemento a 2."/>

  <p>Esto es fundamental cuando decides qué tipo de dato usar: <b>¿cuántos valores necesitas representar?</b> Usar un tipo más pequeño ahorra memoria, pero tiene límites. Usar uno grande permite más rango, pero consume más espacio.</p>

  <h2>Reto 2</h2>
  <p>Usa el tablero de bits para representar los siguientes valores. 
  Activa el modo <b>short</b> (16 bits) o <b>int</b> (32 bits) según se indique en cada pregunta.</p>

  <ul>
    <li>¿Puedes formar el número <code>30000</code> con <code>short</code>?</li>
    <li>¿Y el número <code>40000</code>? ¿Qué pasa si intentas hacerlo con <code>short</code>?</li>
    <li>¿Qué representación binaria tiene el número <code>-1</code> en <code>int</code>?</li>
    <li>¿Y en <code>short</code>?</li>
  </ul>

  <p><i>Consejo:</i> Observa qué sucede con los bits más significativos cuando los valores son negativos o cuando superan el rango permitido.</p>
</div>


    <div class="content hidden" class="content hidden" id="enunciado-ejemplo">
        <h2>Reto 2</h2>
        <p>Con una sola casilla podíamos representar dos cosas diferentes (un peón o ninguna). En este nivel, el objetivo es explorar qué combinaciones son posibles si tenemos dos casillas.</p>
        <p><b>Pero ojo, aquí viene lo interesante:</b> no todas las posiciones valen lo mismo.</p>
        <p>Compruébalo interactuando con el tablero, y descubre cuánto aumenta el número al marcar ciertas casillas.</p>
    </div>

    <div class="content hidden" id="enunciado3">
        <h2>Reto 3</h2>
        <p>Habrás notado, que con cada casilla que añadimos, se duplican las combinaciones. Esto sigue la fórmula <b>2^n</b>, donde <i>n</i> es el número de casillas.
        En este reto, trabajaremos con 3 casillas.</p>
        <p>Como mencionamos antes, no todas las casillas afectan el número de la misma forma: cada una tiene un "peso" diferente. En computación, la casilla que más cambia el valor se llama <b>bit más significativo</b>, y la que menos lo cambia, <b>bit menos significativo</b>.</p>
    </div>

    <div class="content hidden" id="enunciado4">
        <h2>¿Qué es un nibble?</h2>
        <p>Un <b>nibble</b> es un grupo de 4 bits. En otras palabras, cuando usamos 4 casillas, estamos trabajando con un nibble.</p>
        <p>Con estos 4 bits, podemos representar números desde el 0 hasta el 15. Esto se calcula con:<br>- 2^4 = 16 números diferentes posibles.<br>- 2^4 - 1 = 15 : el número máximo representado.</p>

        <p><b>¿Qué tiene de especial un nibble?</b></p>
        <p>Los nibbles son muy útiles porque están directamente relacionados con otro sistema numérico muy usado en computación: el <strong>hexadecimal</strong>.</p>

        <ul>
            <li>Cada 4 bits representan exactamente <strong>un dígito hexadecimal</strong>.</li>
            <li>Por ejemplo:</li>
            <ul>
                <li><code>0000</code> = <strong>0</strong></li>
                <li><code>1010</code> = <strong>A</strong></li>
                <li><code>1111</code> = <strong>F</strong></li>
            </ul>
        </ul>

        <p>Gracias al sistema hexadecimal, podemos escribir grandes cantidades de información binaria de forma más <strong>corta y legible</strong> usando solo letras y números del <strong>0 al F</strong>. </p>
        <p>Por eso, notarás que los <i>colores en diseño web</i>, <i>direcciones de memoria</i>, y muchos lenguajes de bajo nivel usan hexadecimal todo el tiempo.</p>

        <h2>Reto 4</h2>
    </div>

    <div class="content hidden" id="enunciado5">
        <h2>¿Qué es un byte?</h2>
        <p>Ahora trabajaremos con un byte completo (8 bits). Un byte puede representar números desde 0 hasta 255.</p>

        <p><b>Propiedades clave de un byte:</b></p>
        <ul>
            <li>2^8 = 256 números diferentes posibles</li>
            <li>2^8 - 1 = 255 : el número máximo representable</li>
            <li>Puede representar exactamente 2 dígitos hexadecimales (de 0x00 a 0xFF)</li>
        </ul>

        <p><b>Usos comunes de los bytes:</b></p>
        <ul>
            <li>Representación de caracteres ASCII</li>
            <li>Valores de color en imágenes (canales RGB)</li>
            <li>Almacenamiento de números pequeños de manera eficiente</li>
        </ul>

        <h2>Reto 5</h2>
    </div>

    <div class="content hidden" id="enunciado6">
        <h2>¿Qué es el sistema Hexadecimal?</h2>
        <p>El sistema hexadecimal es un sistema numérico de base 16 que utiliza dieciséis símbolos: los dígitos del 0 al 9 y las letras de la A a la F. Fue estandarizado por IBM en 1963.</p>

        <p>Cada dígito hexadecimal representa un nibble, lo que significa que dos dígitos hexadecimales representan un <strong>byte completo</strong>. Donde los números del <strong>1 al 9 representan su análogo en decimal</strong>, y las letras de la <strong>A a la F representan los números del 10 al 15 en decimal</strong>. Por ejemplo:</p>
        <ul>
            <li>0x8 = 4 bits = (8 × 16⁰) = 8</li>
            <li>0xA = 4 bits = (10 × 16⁰) = 10</li>
            <li>0xF = 4 bits = (15 × 16⁰) = 15</li>
            <li>0x8F = 8 bits = (8 × 16¹) + (15 × 16⁰) = 143</li>
            <li>0xAF = 8 bits = (10 × 16¹) + (15 × 16⁰) = 175</li>
            <li>0xFF = 8 bits = (15 × 16¹) + (15 × 16⁰) = 255</li>
        </ul>

        <p><strong>¿Qué tiene de especial el sistema Hexadecimal?</strong></p>
        <p>Su principal ventaja es su relación directa y elegante con el sistema binario, permitiendo una alineación perfecta con la arquitectura de los sistemas informáticos donde la unidad fundamental es el byte. Esto lo hace más práctico que otros sistemas como el octal.</p>

        <p>Es omnipresente en la programación:</p>
        <ul>
            <li><strong>Diseño web:</strong> Para definir colores (ej. #FFFFFF para blanco).</li>
            <li><strong>Desarrollo de software de bajo nivel:</strong> Para especificar direcciones de memoria.</li>
            <li><strong>Otros usos:</strong> Depuración (debugging), configuración de direcciones MAC o IPv6, y manipulación de archivos binarios.</li>
        </ul>

        <p>En esencia, el hexadecimal actúa como un puente vital entre el lenguaje binario de las máquinas y un formato más legible y manipulable para los humanos, facilitando la comprensión de cómo se almacenan y procesan los datos a un nivel fundamental.</p>

        <h2>Reto 6</h2>
    </div>

    <div class="content hidden" id="conclusion" style="min-height: 600px;">
        <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.</p>
    </div>


    <div class="container">
        <div class="card">
            <div id="p5-container" style="text-align: center; vertical-align: middle;"></div>
            <!-- <div class="number-output"> -->
                <!-- <p id="binary-label" class="hidden">Binario: <span id="binary-value">00000000</span></p>
                <p id="decimal-label" class="hidden">Decimal: <span id="decimal-value">0</span></p>
                <p id="hex-label" class="hidden">Hexadecimal: <span id="hex-value">0x0</span></p>
                <p id="data-type-label" class="hidden">Tipo de dato: <span id="data-type">boolean</span></p> -->
            <!-- </div> -->
        </div>

        <div class="card" id="questionCard">
            <div id="questions"></div>
        </div>
    </div>

    <div id="successModal" class="modal">
        </div>


    <div class="footer-fixed">
        <!-- <div class="buttons">
            <button id="previousBtn">Anterior</button>
            <button id="verifyBtn" disabled>Verificar</button>
            <button id="nextBtn">Siguiente</button>
            
        </div> -->
        <div class="buttons">
        <button id="previousBtn">
            <span class="button-text">Anterior</span>
            <img src="../assets/left-arrow.png" alt="Anterior" class="button-icon-img">
        </button>
        <button id="verifyBtn" disabled>Verificar</button>
        <button id="nextBtn">
            <span class="button-text">Siguiente</span>
            <img src="../assets/right-arrow.png" alt="Siguiente" class="button-icon-img">
        </button>

    </div>
        <div class="level-counter" id="levelIndicator">1 / 3</div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/p5@1.4.0/lib/p5.js"></script>
    <script src="quizData.js"></script>
    <script src="quizUI.js"></script>
    <script src="chessBoard.js"></script>
    <script src="quizController.js"></script>
    <script src="sketch.js"></script>
    <script>
        // Create a new p5 instance with your sketch
        let myp5 = new p5(sketchTema2);
    </script>
</body>
</html>